name: Release to PyPI

on:
  release:
    types: [published]
  workflow_dispatch:  # Add manual trigger
    inputs:
      version:
        description: 'Version to release (optional)'
        required: false
        default: ''
      skip_tests:
        description: 'Skip tests (not recommended)'
        required: false
        default: false
        type: boolean

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: release
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        submodules: recursive
    
    - name: Display release info
      run: |
        echo "üöÄ Manual release triggered"
        if [ -n "${{ github.event.inputs.version }}" ]; then
          echo "üì¶ Version: ${{ github.event.inputs.version }}"
        fi
        if [ "${{ github.event.inputs.skip_tests }}" = "true" ]; then
          echo "‚ö†Ô∏è  Tests will be skipped"
        fi
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: "3.9"
    
    - name: Install system dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y cmake build-essential
    
    - name: Build OctoMap C++ library
      run: |
        cd src/octomap
        # Check if cached build has correct paths (handle repo name change)
        if [ -d "build" ] && [ -f "build/CMakeCache.txt" ]; then
          if grep -q "/__w/pyoctomap/pyoctomap" build/CMakeCache.txt 2>/dev/null; then
            echo "‚úÖ Using cached OctoMap C++ build"
            cd build
            make -j$(nproc)
            sudo make install
            sudo ldconfig
          else
            echo "‚ö†Ô∏è  Cached build has old paths, rebuilding..."
            rm -rf build
            mkdir build
            cd build
            cmake ..
            make -j$(nproc)
            sudo make install
            sudo ldconfig
          fi
        else
          echo "üî® Building OctoMap C++ library from scratch..."
          mkdir build
          cd build
          cmake ..
          make -j$(nproc)
          sudo make install
          sudo ldconfig
        fi
    
    - name: Install build tools
      run: |
        python -m pip install --upgrade pip
        pip install build twine setuptools wheel numpy cython pytest
    
    - name: Generate PyPI README
      run: |
        # Generate PyPI README with converted URLs
        python github2pypi/generate_pypi_readme.py
        
        # Verify the PyPI README was created
        if [ -f "README_pypi_preview.md" ]; then
          echo "‚úÖ PyPI README generated successfully"
          echo "üìä File size: $(wc -c < README_pypi_preview.md) bytes"
          echo "üîó Sample URLs:"
          grep -o 'https://github.com/[^)]*' README_pypi_preview.md | head -3
        else
          echo "‚ùå PyPI README generation failed"
          exit 1
        fi
    
    - name: Build distributions
      run: |
        # Clean any previous builds
        rm -rf build/ dist/ *.egg-info/
        
        # Verify PyPI README exists before building
        if [ ! -f "README_pypi_preview.md" ]; then
          echo "‚ùå PyPI README not found, generating it..."
          python github2pypi/generate_pypi_readme.py
        fi
        
        # Build both wheel and source distribution
        python setup.py bdist_wheel sdist
        
        # Fix platform tags for PyPI compatibility using auditwheel
        pip install auditwheel
        
        # Create repaired wheels directory
        mkdir -p wheelhouse
        
        # Repair wheels for manylinux compatibility
        for wheel in dist/*.whl; do
          if [[ -f "$wheel" ]]; then
            echo "Repairing wheel: $wheel"
            auditwheel repair "$wheel" -w wheelhouse/ || {
              echo "auditwheel failed, trying manual tag fix..."
              cp "$wheel" wheelhouse/
              cd wheelhouse
              python -c "import os; [os.rename(f, f.replace('linux_x86_64', 'manylinux1_x86_64')) for f in os.listdir('.') if f.endswith('.whl') and 'linux_x86_64' in f]; print('Fixed platform tags')"
              cd ..
            }
          fi
        done
        
        # Replace original wheels with repaired ones
        rm -f dist/*.whl
        cp wheelhouse/*.whl dist/ 2>/dev/null || echo "No wheels to copy"
        
        echo "Final distributions:"
        ls -la dist/
    
    - name: Check distributions
      run: |
        twine check dist/*
        echo "üì¶ Built distributions:"
        ls -la dist/
        
        # Verify PyPI README is included in the package
        echo "üîç Checking package contents:"
        python -c "
        import zipfile
        import os
        for file in os.listdir('dist'):
            if file.endswith('.whl'):
                with zipfile.ZipFile(f'dist/{file}', 'r') as zf:
                    files = zf.namelist()
                    readme_files = [f for f in files if 'readme' in f.lower()]
                    print(f'README files in {file}: {readme_files}')
        "
    
    - name: Publish to PyPI
      uses: pypa/gh-action-pypi-publish@release/v1
      with:
        user: __token__
        password: ${{ secrets.PYPI_API_TOKEN }}
    
    - name: Verify PyPI README
      run: |
        echo "‚úÖ PyPI README verification:"
        echo "üìÅ PyPI README file: README_pypi_preview.md"
        if [ -f "README_pypi_preview.md" ]; then
          echo "‚úÖ File exists"
          echo "üìä Size: $(wc -c < README_pypi_preview.md) bytes"
          echo "üîó Contains GitHub URLs: $(grep -c 'https://github.com' README_pypi_preview.md || echo '0')"
          echo "Ô∏è Contains images: $(grep -c '!\[.*\](.*github.*)' README_pypi_preview.md || echo '0')"
        else
          echo "‚ùå PyPI README file not found"
          exit 1
        fi
    
    - name: Upload PyPI README artifact
      uses: actions/upload-artifact@v4
      with:
        name: pypi-readme
        path: README_pypi_preview.md
        retention-days: 30